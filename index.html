<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>CRYPTOGRAPHYTUBE TOOLS</title>

<script src="https://cdnjs.cloudflare.com/ajax/libs/elliptic/6.5.5/elliptic.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css">

<style>
/* --- Bitcoin Inspired Theme --- */
:root {
    --bitcoin-orange: #ff9900;
    --dark-bg: #1e1e1e;
    --card-bg: #2d2d30;
    --text-color: #f0f0f0;
    --highlight-green: #00cc00;
}

body { 
    font-family: 'Arial', sans-serif; 
    padding: 20px; 
    max-width: 800px; 
    margin: auto; 
    background-color: var(--dark-bg); 
    color: var(--text-color);
}
input, button, textarea { 
    width: 100%; 
    padding: 12px; 
    margin-top: 10px; 
    border: 1px solid #444; 
    border-radius: 6px; 
    box-sizing: border-box;
    background-color: #3e3e3e;
    color: var(--text-color);
}
button { 
    background-color: var(--bitcoin-orange); 
    color: #1e1e1e; 
    font-weight: bold;
    cursor: pointer; 
    border: none; 
    transition: background-color 0.3s; 
}
button:hover { background-color: #ffa520; }
pre { 
    background: #111; 
    color: var(--highlight-green); 
    padding: 15px; 
    overflow: auto; 
    white-space: pre-wrap; 
    word-wrap: break-word; 
    border-radius: 6px; 
    font-size: 14px; 
    border: 1px solid #444;
}
.section { 
    margin-top: 35px; 
    padding: 20px; 
    border: 1px solid #444; 
    border-radius: 8px; 
    background-color: var(--card-bg); 
    box-shadow: 0 4px 8px rgba(0,0,0,0.5); 
}
.private-key { color: #ff5555; font-weight: bold; }
/* Highlighted text for range difference */
.highlight-range { color: #ff5555; }

h2 { 
    color: var(--bitcoin-orange); 
    border-bottom: 2px solid var(--bitcoin-orange); 
    padding-bottom: 10px; 
    text-align: center;
}
h3 { color: var(--text-color); margin-top: 0; }
.header-links { 
    text-align: center; 
    margin-bottom: 25px; 
    display: flex; 
    justify-content: center;
}
.header-links a { 
    margin: 0 15px; 
    color: var(--text-color); 
    font-size: 24px; 
    text-decoration: none;
    transition: color 0.3s;
}
.header-links a:hover { color: var(--bitcoin-orange); }
.header-links .fa-github { color: #fff; }
.header-links .fa-telegram { color: #0088cc; }
.attribution { display: none; }
.result-header {
    border-bottom: 2px dashed #444;
    padding-bottom: 8px;
    margin-bottom: 12px;
    color: var(--bitcoin-orange);
    font-weight: bold;
}
.result-header .author {
    color: var(--text-color);
    font-size: 0.9em;
    display: block;
    margin-top: 4px;
}
.input-group {
    display: flex;
    gap: 10px;
}
.input-group input {
    flex-grow: 1;
}
</style>
</head>
<body>

<h2>CRYPTOGRAPHYTUBE TOOLS</h2>
<div class="header-links">
    <a href="https://github.com/Cryptographytube" target="_blank" title="GitHub"><i class="fab fa-github"></i> GitHub</a>
    <a href="https://t.me/cryptographytube" target="_blank" title="Telegram Channel"><i class="fab fa-telegram"></i> Channel</a>
    <a href="https://t.me/cryptographytube" target="_blank" title="Telegram Group"><i class="fab fa-telegram"></i> Group</a>
</div>

<div class="section">
<h3>1. TXID → R, S, Z, Address + Private Key Recovery (R-Reuse)</h3>
<input id="txid_input" placeholder="Enter Bitcoin Transaction ID (TXID)">
<button onclick="processTxid()">Analyze Transaction (R-S-Z)</button>
<pre id="out_txid">
Instructions:
1. Enter a TXID.
2. If two consecutive inputs share the same R-Value (R-reuse), the Private Key will be recovered.
3. Internet connection is required for API access.
</pre>
</div>

---

<div class="section">
<h3>2. Address → HASH160 / Witness Program</h3>
<input id="addr2" placeholder="Enter Bitcoin Address (P2PKH: 1..., P2SH: 3..., Bech32: bc1q...)">
<button onclick="addrToHash()">Convert to Hash160</button>
<pre id="out_hash">
</pre>
</div>

---

<div class="section">
<h3>3. Public Key → X and Y Coordinates</h3>
<input id="pk_coords" placeholder="Enter Compressed (66 hex) or Uncompressed (130 hex) Public Key">
<button onclick="pubToCoords()">Extract Coordinates</button>
<pre id="out_pk_coords">
</pre>
</div>

---

<div class="section">
<h3>4. Public Key → Address (Compressed & Uncompressed)</h3>
<input id="pk" placeholder="Enter Public Key Hex">
<button onclick="pubToAddr()">Convert to Address</button>
<pre id="out_pk">
</pre>
</div>

---

<div class="section">
<h3>5. Private Key → Public Key / Address</h3>
<input id="priv" placeholder="Enter WIF or 64 Hex Private Key">
<button onclick="privToPub()">Convert</button>
<pre id="out_priv">
</pre>
</div>

---

<div class="section">
<h3>6. Address → Public Key (API Lookup)</h3>
<input id="addr" placeholder="Enter Bitcoin Address (P2PKH: 1...)">
<button onclick="findPublicKey()">Find Public Key</button>
<pre id="out_addr">
Note: Public Key is only available for P2PKH addresses that have been spent from (API lookup required).
</pre>
</div>

---

<div class="section">
<h3>7. HASH160 (RIPEMD160) → Address (P2PKH & P2SH)</h3>
<input id="rmd160_input" placeholder="Enter 40-character RIPEMD160 Hash (HASH160)">
<button onclick="rmdToAddress()">Convert to Addresses</button>
<pre id="out_rmd160">
</pre>
</div>

---

<div class="section">
<h3>8. WIF Key → Hex Private Key + Addresses (All Details)</h3>
<input id="wif_to_hex_input" placeholder="Enter Compressed (K/L...) or Uncompressed (5...) WIF Private Key">
<button onclick="wifToHexDetails()">Convert WIF</button>
<pre id="out_wif_to_hex">
</pre>
</div>

---

<div class="section">
<h3>9. Hex Private Key → WIF Key + Addresses (All Details)</h3>
<input id="hex_to_wif_input" placeholder="Enter 64-character Hex Private Key">
<button onclick="hexToWifDetails()">Convert Hex</button>
<pre id="out_hex_to_wif">
</pre>
</div>

---

<div class="section">
<h3>10. WIF Key → Missing Private Key Decode (WIF Range)</h3>
<input id="wif_range_input" placeholder="Enter WIF with missing characters (use * for missing characters)">
<button onclick="wifMissingKeyDecode()">Decode WIF Range</button>
<pre id="out_wif_range">
Instructions:
Enter a WIF key where the missing characters are replaced by an asterisk (*).
Example: 5J*d*2V
</pre>
</div>

---

<div class="section">
<h3>11. Address → Vulnerability Check (R-Reuse/Bias)</h3>
<input id="vuln_addr_input" placeholder="Enter Bitcoin Address (Legacy or P2SH)">
<div class="input-group">
    <input id="vuln_tx_count" type="number" value="100" min="1" placeholder="Number of Transactions to Fetch">
</div>
<button onclick="checkAddressVulnerability()">Process Transactions</button>
<pre id="out_vuln_check">
Instructions:
Enter a P2PKH (1...) or P2SH (3...) address and the number of transactions to analyze.
This tool checks for repeated ECDSA R-values (nonce reuse) in the latest transactions, which indicates a severe vulnerability.
</pre>
</div>


<script>
// =================================================================
// 0. CORE UTILITIES AND CONSTANTS
// =================================================================
const ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
const BASE = BigInt(58);
const BECH32_ALPHABET = 'qpzry9x8gf2tvdsigunpkfclmjwh';
const N = BigInt('0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141');

// Function to generate the custom output header
function getOutputHeader() {
    return `<div class="result-header">CRYPTOGRAPHYTUBE<span class="author">AUTHOR: Sisujhon</span></div>\n`;
}

// Hashing Functions
function sha256hex(hex){ return CryptoJS.SHA256(CryptoJS.enc.Hex.parse(hex)).toString(); }
function ripe160hex(hex){ return CryptoJS.RIPEMD160(CryptoJS.enc.Hex.parse(hex)).toString(); }
function dblsha256(hex){ return sha256hex(sha256hex(hex)); }

// Converters
function hexToBytes(hex) {
    if (hex.length % 2 !== 0) hex = '0' + hex;
    return new Uint8Array(hex.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));
}
function bytesToHex(bytes) {
    return Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('');
}
function hexToBigInt(hex) { return BigInt('0x' + hex); }

// Math
function modInverse(a, m) {
    let m0 = m;
    let x0 = 0n;
    let x1 = 1n;
    a %= m;

    while (a > 1n) {
        let q = a / m;
        let t = m;

        m = a % m;
        a = t;

        t = x0;
        x0 = x1 - q * x0;
        x1 = t;
    }

    if (x1 < 0n) {
        x1 += m0;
    }
    return x1;
}

function countBits(num) {
    if (num <= 0n) return 0;
    return num.toString(2).length;
}

function reverseHex(hex) {
    if (hex.length % 2 !== 0) throw new Error("Hex string length is odd.");
    return hex.match(/.{1,2}/g).reverse().join('');
}

// =================================================================
// 1. BASE58 UTILITIES (P2PKH, P2SH, WIF)
// =================================================================
function b58decode(str){
    let num = BigInt(0);
    for(const char of str){ 
        const index = ALPHABET.indexOf(char);
        if (index === -1) throw new Error(`Invalid Base58 character: ${char}`);
        num = num * BASE + BigInt(index); 
    }
    let hex = num.toString(16);
    
    let leadingOnes = 0;
    for(let i = 0; i < str.length && str[i] === '1'; i++){ leadingOnes++; }
    let leadingZeros = "00".repeat(leadingOnes);
    
    let totalLength = leadingZeros.length + hex.length;
    if (totalLength % 2 !== 0 && str.length > 0) {
        hex = "0" + hex;
    }

    return leadingZeros + hex;
}

function b58encode(hex){
    let num = BigInt("0x"+hex);
    let str = "";
    while(num > 0){
        const r = Number(num % 58n);
        str = ALPHABET[r] + str;
        num /= 58n;
    }
    let leadingZeros = "";
    for(let i=0; i<hex.length; i+=2){
        if(hex.substring(i, i+2) === "00"){
            leadingZeros += "1";
        } else {
            break;
        }
    }
    return leadingZeros + str;
}

function b58_decode_check(encoded) {
    const hex = b58decode(encoded);
    const data_and_checksum = hexToBytes(hex);
    
    if (data_and_checksum.length < 4) throw new Error('Decoded length is too short for checksum check.');

    const data = data_and_checksum.slice(0, data_and_checksum.length - 4);
    const checksum = data_and_checksum.slice(data_and_checksum.length - 4);

    const dataHex = bytesToHex(data);
    const hash = dblsha256(dataHex);
    const calculatedChecksum = hash.substring(0, 8);
    
    if (bytesToHex(checksum) !== calculatedChecksum) {
        throw new Error('Checksum mismatch.');
    }
    
    return data;
}

function simple_b58_decode(encoded) {
    const hex = b58decode(encoded);
    const data_and_checksum = hexToBytes(hex);
    return data_and_checksum;
}


// =================================================================
// 2. ADDRESS/KEY GENERATION UTILITIES
// =================================================================
function hash160ToAddress(hash160, version_byte) {
    const versioned_hash = version_byte + hash160;
    const checksum = dblsha256(versioned_hash).substring(0, 8);
    return b58encode(versioned_hash + checksum);
}

function pubToAddr_P2PKH(pub_hex) {
    const pub_bin = hexToBytes(pub_hex);
    const sha256_hash = sha256hex(bytesToHex(pub_bin));
    const ripemd160_hash = ripe160hex(sha256_hash);
    
    return hash160ToAddress(ripemd160_hash, "00");
}

function privHexToWIF(hex, compressed) {
    const versioned_hex = "80" + hex;
    let wif_data = versioned_hex;

    if (compressed) {
        wif_data += "01"; 
    }
    
    const checksum = dblsha256(wif_data).substring(0, 8);
    return b58encode(wif_data + checksum);
}

function getFullKeyDetails(privateKeyHex) {
    const ec = new elliptic.ec("secp256k1");
    const kp = ec.keyFromPrivate(privateKeyHex);
    const pub = kp.getPublic();

    const compressedPub = pub.encode('hex', true);
    const addressComp = pubToAddr_P2PKH(compressedPub);
    const wifCompressed = privHexToWIF(privateKeyHex, true);
    
    const uncompressedPub = pub.encode('hex', false);
    const addressUncomp = pubToAddr_P2PKH(uncompressedPub);
    const wifUncompressed = privHexToWIF(privateKeyHex, false);
    
    return {
        hex: privateKeyHex,
        compressedPub,
        uncompressedPub,
        addressComp,
        addressUncomp,
        wifCompressed,
        wifUncompressed
    };
}

/* ---------------------- 10. WIF Range Decoder (IMPROVED) ---------------------- */

function highlightDifference(start, end) {
    let common = '';
    let i = 0;
    while (i < start.length && i < end.length && start[i] === end[i]) {
        common += start[i];
        i++;
    }
    const diffStart = `<span class='highlight-range'>${start.substring(i)}</span>`;
    const diffEnd = `<span class='highlight-range'>${end.substring(i)}</span>`;
    return { diffStart: common + diffStart, diffEnd: common + diffEnd };
}

function wifMissingKeyDecode() {
    const wif_input = document.getElementById("wif_range_input").value.trim();
    const out = document.getElementById("out_wif_range");
    out.innerHTML = '';

    if (!wif_input.includes('*')) {
        out.innerHTML = getOutputHeader() + `<pre><span class='private-key'>Error: Please use the asterisk (*) to denote missing characters. Example: 5J*d*2V</span></pre>`;
        return;
    }

    const wif_filled_1 = wif_input.replace(/\*/g, '1');
    const wif_filled_z = wif_input.replace(/\*/g, 'z');

    let mode;
    if (wif_filled_1.length === 51) {
        mode = "Uncompressed (Legacy)";
    } else if (wif_filled_1.length === 52) {
        mode = "Compressed (Standard)";
    } else {
        out.innerHTML = getOutputHeader() + `<pre><span class='private-key'>Error: Invalid resulting WIF length (${wif_filled_1.length}). Must be 51 or 52 characters.</span></pre>`;
        return;
    }
    
    try {
        // Decode both WIF variations
        const hex_bytes_1 = simple_b58_decode(wif_filled_1);
        const hex_1 = bytesToHex(hex_bytes_1);
        
        const hex_bytes_z = simple_b58_decode(wif_filled_z);
        const hex_z = bytesToHex(hex_bytes_z);

        // Extract private key ranges based on WIF type
        let privkey_start;
        let privkey_end;
        
        if (mode.startsWith("Compressed")) {
            // For compressed WIF: version(1) + private key(32) + compression flag(1) + checksum(4)
            privkey_start = hex_1.substring(2, 66); // Skip version byte (80) and get private key
            privkey_end = hex_z.substring(2, 66);
        } else {
            // For uncompressed WIF: version(1) + private key(32) + checksum(4)
            privkey_start = hex_1.substring(2, 66); // Skip version byte (80) and get private key
            privkey_end = hex_z.substring(2, 66);
        }

        // Convert to BigInt for range calculation
        const int_start = hexToBigInt(privkey_start);
        const int_end = hexToBigInt(privkey_end);
        const combinations = int_end - int_start + 1n;
        const bit_range = countBits(combinations);

        const diffs = highlightDifference(privkey_start, privkey_end);

        let content = 
            `Input WIF Template: ${wif_input}\n` +
            `Detected Mode: ${mode.toUpperCase()}\n\n` +
            `1. WIF (Low Range): ${wif_filled_1}\n` +
            `   Hex Decoded: ${hex_1}\n\n` +
            `2. WIF (High Range): ${wif_filled_z}\n` +
            `   Hex Decoded: ${hex_z}\n\n` +
            `--- PRIVATE KEY HEX RANGE (d) ---\n` +
            `Start (from): ${diffs.diffStart}\n` +
            `End (to):     ${diffs.diffEnd}\n\n` +
            `Total Combinations: ${combinations.toLocaleString('en-US')}\n` +
            `Bit Range: ${bit_range} bits`;

        out.innerHTML = getOutputHeader() + `<pre>${content}</pre>`;

    } catch(e) {
        out.innerHTML = getOutputHeader() + `<pre><span class='private-key'>Error during range calculation: ${e.message}.</span></pre>`;
    }
}

/* ---------------------- 11. Address Vulnerability Check (NEW) ---------------------- */

// Helper to parse DER-encoded ECDSA signatures (robust, as per Python logic)
function tryParseDerAt(buf, pos) {
    if (!buf || pos + 7 > buf.length) return null;
    try {
        if (buf[pos] !== 0x30) return null; // SEQUENCE (0x30)

        const total_len = buf[pos + 1];
        if (total_len < 6) return null;
        const end = pos + 2 + total_len;
        if (end > buf.length) return null;

        if (buf[pos + 2] !== 0x02) return null; // INTEGER (R-value)

        const r_len = buf[pos + 3];
        const r_start = pos + 4;
        const r_end = r_start + r_len;
        if (r_end >= buf.length || r_end >= end) return null;

        if (buf[r_end] !== 0x02) return null; // INTEGER (S-value)

        const s_len = buf[r_end + 1];
        const s_start = r_end + 2;
        const s_end = s_start + s_len;
        if (s_end > buf.length || s_end > end) return null;

        const r_bytes = buf.slice(r_start, r_end);
        const s_bytes = buf.slice(s_start, s_end);
        
        // Remove leading zero byte if present (DER canonicalization)
        let r_hex = bytesToHex(r_bytes);
        let s_hex = bytesToHex(s_bytes);
        if (r_hex.startsWith('00') && r_hex.length > 2) r_hex = r_hex.substring(2);
        if (s_hex.startsWith('00') && s_hex.length > 2) s_hex = s_hex.substring(2);

        const consumed = end - pos;
        return { r: r_hex, s: s_hex, len: consumed };

    } catch (e) {
        return null;
    }
}

function extractEcdsaSigs(script_hex) {
    const results = [];
    if (!script_hex || typeof script_hex !== 'string') return results;
    
    // Attempt to convert to bytes, handling common hex formats
    let buf;
    try {
        if (script_hex.startsWith("0x")) script_hex = script_hex.substring(2);
        buf = hexToBytes(script_hex.replace(/\s/g, ''));
    } catch {
        return results;
    }

    let i = 0;
    while (i < buf.length) {
        const maybe = tryParseDerAt(buf, i);
        if (maybe) {
            results.push({ r: maybe.r, s: maybe.s, offset: i, raw_hex: bytesToHex(buf.slice(i, i + maybe.len)) });
            i += maybe.len;
        } else {
            i += 1; // Skip one byte and try again
        }
    }
    return results;
}

// Function to fetch and process transactions for vulnerability check
async function checkAddressVulnerability() {
    const addr = document.getElementById("vuln_addr_input").value.trim();
    const count = parseInt(document.getElementById("vuln_tx_count").value.trim());
    const out = document.getElementById("out_vuln_check");
    out.innerHTML = getOutputHeader() + "<pre>Processing address...</pre>";
    
    if (addr.length < 26) {
        out.innerHTML = getOutputHeader() + `<pre><span class='private-key'>Error: Invalid address length.</span></pre>`;
        return;
    }
    
    if (addr.startsWith('bc1') || addr.startsWith('tb1')) {
        out.innerHTML = getOutputHeader() + `<pre>❌ Skipping: This tool only supports Legacy (1...) and P2SH (3...) addresses due to complex SegWit/Taproot witness structure.</pre>`;
        return;
    }
    if (isNaN(count) || count < 1) {
        out.innerHTML = getOutputHeader() + `<pre><span class='private-key'>Error: Transaction count must be a positive number.</span></pre>`;
        return;
    }

    // --- Fetch Transactions ---
    // Note: Blockchain.info often limits transactions per call, but we keep it simple for web implementation.
    const url = `https://blockchain.info/address/${addr}?format=json&limit=${count}`;
    
    out.innerHTML = getOutputHeader() + `<pre>Fetching ${count} transactions from Blockchain.info (may take time)...</pre>`;

    let txs;
    try {
        const response = await fetch(url);
        if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
        const data = await response.json();
        txs = data.txs || data.transactions || [];
        
        if (txs.length === 0 && data.n_tx === 0) {
            out.innerHTML = getOutputHeader() + `<pre>✅ No transactions found for this address. (Vulnerability: None)</pre>`;
            return;
        }
    } catch (e) {
        out.innerHTML = getOutputHeader() + `<pre><span class='private-key'>❌ Error fetching transactions: ${e.message}. (API limit or CORS issue)</span></pre>`;
        return;
    }

    out.innerHTML = getOutputHeader() + `<pre>Found ${txs.length} transactions. Analyzing for R-reuse...</pre>`;

    // --- Analysis ---
    const allROccurrences = {};
    const crossTxAlerts = [];
    let transactionCount = 0;

    for (const tx of txs) {
        const txid = tx.hash || tx.txid || "<unknown>";
        transactionCount++;

        const vinList = tx.inputs || tx.vin || [];
        
        for (const vin of vinList) {
            // Get the raw scriptSig/witness data
            const scriptHex = vin.script || vin.scriptsig || vin.scriptSig || '';

            // 1. Check ScriptSig (Legacy/P2SH)
            if (scriptHex) {
                const sigs = extractEcdsaSigs(scriptHex);
                for (const s of sigs) {
                    const r = s.r;
                    if (!allROccurrences[r]) allROccurrences[r] = [];
                    allROccurrences[r].push({ txid: txid, where: 'vin-scriptsig', index: vin.sequence });
                }
            }
            // Skipping witness parsing for simplicity and focus on legacy/P2SH
        }
    }
    
    // --- Post-Analysis Compilation ---
    const vulnFlags = new Set();
    const vulnerableTxids = new Set();

    for (const r in allROccurrences) {
        const occs = allROccurrences[r];
        const txids = new Set(occs.map(o => o.txid));
        
        if (txids.size > 1) {
            vulnFlags.add("REPEATED NONCE (R-Value Reuse) - HIGH VULNERABILITY");
            txids.forEach(id => vulnerableTxids.add(id)); // Collect all TXIDs involved in reuse
            crossTxAlerts.push({ r: r, occurrences: occs, tx_count: txids.size });
        }
        
        // Simple check for general R-value bias (e.g., used 4+ times overall)
        if (occs.length >= 4) {
             vulnFlags.add("BIAS/PREDICTABLE NONCE - (R-Value used 4+ times overall)");
        }
    }

    let output_content = `\nAddress: ${addr}\nTransactions Analyzed: ${transactionCount}\n\n`;
    
    if (vulnFlags.size > 0) {
        output_content += "========================================================\n";
        output_content += "!!! VULNERABILITY ALERT !!!\n";
        output_content += "========================================================\n";
        output_content += "Detected Issues:\n";
        vulnFlags.forEach(v => {
            output_content += `<span class='private-key'>-> ${v}</span>\n`;
        });
        
        if (vulnerableTxids.size > 0) {
            output_content += "\n--- VULNERABLE TRANSACTION IDS (TXIDs) ---\n";
            vulnerableTxids.forEach(txid => {
                 output_content += `${txid}\n`;
            });
            output_content += `\nTotal Vulnerable TXIDs: ${vulnerableTxids.size}\n`;
        }
        
        output_content += "\n--- Details (R-Values) ---\n";
        crossTxAlerts.forEach(a => {
            output_content += `[R-Value]: ${a.r}\n`;
            output_content += `  Reused in ${a.tx_count} different TXIDs.\n`;
        });

    } else {
        output_content += "========================================================\n";
        output_content += "✅ NO R-VALUE REUSE VULNERABILITY DETECTED\n";
        output_content += "========================================================\n";
    }

    out.innerHTML = getOutputHeader() + `<pre>${output_content}</pre>`;
}

/* --- Other Functions (1-9) defined below --- */

function privToPub(){
    const out = document.getElementById("out_priv");
    out.innerHTML = '';
    
    try{
        let key = document.getElementById("priv").value.trim();
        let hex;
        
        if(key.length === 64){
            hex = key;
        } else {
            const decodedBytes = b58_decode_check(key);
            if (decodedBytes[0] !== 0x80) throw new Error("Not a Bitcoin Mainnet Private Key (Version 80).");
            const decodedHex = bytesToHex(decodedBytes);
            
            if (decodedHex.length === 66) { 
                hex = decodedHex.substring(2);
            } else if (decodedHex.length === 68 && decodedHex.endsWith('01')) { 
                hex = decodedHex.substring(2, 66);
            } else {
                 throw new Error("Invalid WIF structure or length.");
            }
        }
        
        const details = getFullKeyDetails(hex);

        let content =
            "Private Key (Hex): " + details.hex + "\n\n" +
            "--- COMPRESSED KEY INFO ---\n" +
            "1. Public Key (Compressed): " + details.compressedPub + "\n" +
            "2. P2PKH Address: " + details.addressComp + " (Standard)\n" +
            "3. WIF (Compressed): " + details.wifCompressed + " (K/L...)\n\n" +
            "--- UNCOMPRESSED KEY INFO ---\n" +
            "4. Public Key (Uncompressed): " + details.uncompressedPub + "\n" +
            "5. P2PKH Address: " + details.addressUncomp + " (Legacy)\n" +
            "6. WIF (Uncompressed): " + details.wifUncompressed + " (5...)";

        out.innerHTML = getOutputHeader() + `<pre>${content}</pre>`;

    } catch(e){ 
        out.innerHTML = getOutputHeader() + `<pre>Error: Invalid Private Key format or checksum. ${e.message}.</pre>`;
    }
}

function wifToHexDetails() {
    const wif = document.getElementById("wif_to_hex_input").value.trim();
    const out = document.getElementById("out_wif_to_hex");
    out.innerHTML = '';

    try {
        const decodedBytes = b58_decode_check(wif);
        if (decodedBytes[0] !== 0x80) throw new Error("Not a Bitcoin Mainnet Private Key (Version 80).");
        
        const decodedHex = bytesToHex(decodedBytes);
        let hex;
        let compressionFlag = "No Flag (Uncompressed)";
        
        if (decodedHex.length === 66) { 
            hex = decodedHex.substring(2);
        } else if (decodedHex.length === 68 && decodedHex.endsWith('01')) { 
            hex = decodedHex.substring(2, 66);
            compressionFlag = "01 (Compressed)";
        } else {
             throw new Error("Invalid WIF structure or length.");
        }
        
        const details = getFullKeyDetails(hex);

        let content =
            "Input WIF Key: " + wif + "\n" +
            "WIF Type Flag: " + compressionFlag + "\n\n" +
            "--- HEX PRIVATE KEY ---\n" +
            "Hex Private Key (d): " + details.hex + "\n\n" +
            "--- ADDRESSES & PUBLIC KEYS ---\n" +
            "1. Public Key (Compressed): " + details.compressedPub + "\n" +
            "2. P2PKH Address (Compressed Hash): " + details.addressComp + " (Standard)\n\n" +
            "3. Public Key (Uncompressed): " + details.uncompressedPub + "\n" +
            "4. P2PKH Address (Uncompressed Hash): " + details.addressUncomp + " (Legacy)";

        out.innerHTML = getOutputHeader() + `<pre>${content}</pre>`;

    } catch(e) {
        out.innerHTML = getOutputHeader() + `<pre><span class='private-key'>Error: Invalid WIF Key or Checksum mismatch. ${e.message}</span></pre>`;
    }
}

function hexToWifDetails() {
    const hex = document.getElementById("hex_to_wif_input").value.trim().toLowerCase();
    const out = document.getElementById("out_hex_to_wif");
    out.innerHTML = '';

    if (hex.length !== 64 || !/^[0-9a-f]{64}$/.test(hex)) {
        out.innerHTML = getOutputHeader() + `<pre><span class='private-key'>Error: Invalid Hex Private Key. Must be a 64-character hexadecimal string.</span></pre>`;
        return;
    }

    try {
        const details = getFullKeyDetails(hex);

        let content =
            "Input Hex Private Key (d): " + details.hex + "\n\n" +
            "--- COMPRESSED WIF KEY INFO ---\n" +
            "1. WIF Key (Compressed): " + details.wifCompressed + " (K/L...)\n" +
            "2. Public Key: " + details.compressedPub + "\n" +
            "3. P2PKH Address: " + details.addressComp + " (Standard)\n\n" +
            "--- UNCOMPRESSED WIF KEY INFO ---\n" +
            "4. WIF Key (Uncompressed): " + details.wifUncompressed + " (5...)\n" +
            "5. Public Key: " + details.uncompressedPub + "\n" +
            "6. P2PKH Address: " + details.addressUncomp + " (Legacy)";

        out.innerHTML = getOutputHeader() + `<pre>${content}</pre>`;

    } catch(e) {
        out.innerHTML = getOutputHeader() + `<pre>Error during conversion: ${e.message || "An unexpected error occurred."}</pre>`;
    }
}

/* ---------------------- Remaining Previous Options (1-4, 6, 7) ---------------------- */

// --- Bech32 Utility ---
function convertbits(data, frombits, tobits, pad) {
    let acc = 0;
    let bits = 0;
    const ret = [];
    const maxv = (1 << tobits) - 1;

    for (const value of data) {
        if (value < 0 || value >> frombits !== 0) return null;
        acc = (acc << frombits) | value;
        bits += frombits;
        while (bits >= tobits) {
            bits -= tobits;
            ret.push((acc >> bits) & maxv);
        }
    }
    if (pad) {
        if (bits > 0) {
            ret.push((acc << (tobits - bits)) & maxv);
        }
    } else if (bits >= frombits || ((acc << (tobits - bits)) & maxv)) {
        return null;
    }
    return ret;
}

function bech32_decode_program(address) {
    const lower = address.toLowerCase();
    const separator = lower.lastIndexOf('1');
    const data = lower.substring(separator + 1);

    const data_words = [];
    for (const char of data) {
        const index = BECH32_ALPHABET.indexOf(char);
        if (index === -1) throw new Error('Invalid Bech32 character');
        data_words.push(index);
    }
    
    if (data_words.length < 6) throw new Error('Invalid Bech32 data length');
    
    const data_payload = data_words.slice(0, data_words.length - 6);
    const program_bytes = convertbits(data_payload, 5, 8, false);

    if (program_bytes === null || program_bytes.length < 1) {
        throw new Error('Invalid Bech32 data conversion');
    }

    const version = program_bytes[0];
    const program = new Uint8Array(program_bytes.slice(1));

    return { version, program };
}

/* ---------------------- 1. TXID → R-S-Z + Recovery ---------------------- */
async function getRawTx(txid) {
    const url_big_endian = `https://blockchain.info/rawtx/${txid}?format=hex`;
    
    let rawtx = null;

    try {
        const response = await fetch(url_big_endian, { signal: AbortSignal.timeout(10000) });
        if (response.ok) {
            rawtx = await response.text();
            if (rawtx.length > 100 && !rawtx.includes("Transaction not found")) return rawtx.trim();
        }
    } catch (e) {}

    const reversed_txid = reverseHex(txid);
    const url_little_endian = `https://blockstream.info/api/tx/${reversed_txid}/hex`;
    try {
        const response = await fetch(url_little_endian, { signal: AbortSignal.timeout(10000) });
        if (response.ok) {
            rawtx = await response.text();
            if (rawtx.length > 100 && !rawtx.includes("Transaction not found")) return rawtx.trim();
        }
    } catch (e) {}

    if (!rawtx || rawtx.length < 100) {
        throw new Error("Could not fetch raw transaction data from multiple sources.");
    }

    return rawtx;
}

function getRS(sig) {
    let r_len = parseInt(sig.substring(2, 4), 16);
    let r = sig.substring(4, 4 + r_len * 2);
    let s_start_index = 8 + r_len * 2;
    let s = sig.substring(s_start_index);
    return { r, s };
}

function parseScriptSig(scr) {
    let sigL = parseInt(scr.substring(2, 4), 16);
    let sigs = scr.substring(2 + 2, 2 + sigL * 2);
    
    const { r, s } = getRS(sigs.substring(4)); 

    let pubL_start = 4 + sigL * 2;
    let pub = scr.substring(pubL_start + 2);
    
    if (pub.length !== 66 && pub.length !== 130) {
        throw new Error("Invalid Public Key length in scriptSig.");
    }
    
    return { r, s, pub };
}

function parsingRaw(txRaw) {
    let inputLst = [];
    
    if (txRaw.substring(8, 12) === '0001') {
        throw new Error("Witness data found. Only Legacy P2PKH transactions are supported for R-Reuse analysis.");
    }

    const inputNo = parseInt(txRaw.substring(8, 10), 16);
    let cur = 10;
    
    for (let g = 0; g < inputNo; g++) {
        const pre_out = txRaw.substring(cur, cur + 64);
        const var0 = txRaw.substring(cur + 64, cur + 64 + 8); 
        cur += 64 + 8;
        
        const scrL = parseInt(txRaw.substring(cur, cur + 2), 16);
        const scr = txRaw.substring(cur, 2 + cur + 2 * scrL); 
        
        const { r, s, pub } = parseScriptSig(scr);

        const seq_start = 2 + cur + 2 * scrL;
        const seq = txRaw.substring(seq_start, seq_start + 8); 
        
        inputLst.push({ pre_out, var0, r, s, pub, seq });
        cur = seq_start + 8;
    }
    const hsl = txRaw.substring(cur); 
    
    return { no1: txRaw.substring(0, 10), inputLst, hsl };
}


function getrsz(pars) {
    const result = [];
    const { no1, inputLst, hsl } = pars;
    const tot = inputLst.length;
    
    for (let x = 0; x < tot; x++) {
        let e = no1; 
        for (let i = 0; i < tot; i++) {
            const input = inputLst[i];
            e += input.pre_out;
            e += input.var0;
            
            if (x === i) {
                const hash160 = ripe160hex(sha256hex(input.pub));
                e += '1976a914' + hash160 + '88ac';
            } else {
                e += '00';
            }
            e += input.seq;
        }
        e += hsl + "01000000";

        const z_hex = dblsha256(e); 
        const addr = pubToAddr_P2PKH(inputLst[x].pub);
        
        result.push({ r: inputLst[x].r, s: inputLst[x].s, z: z_hex, pub: inputLst[x].pub, raw_signing_data: e, addr: addr, input_index: x });
    }
    return result;
}

function recover_private_key(R, S1, S2, Z1, Z2) {
    try {
        const R_inv = modInverse(R, N);
        
        const S_diff = (S1 - S2 + N) % N; 
        const S_diff_inv = modInverse(S_diff, N);
        const Z_diff = (Z1 - Z2 + N) % N; 
        const k = (Z_diff * S_diff_inv) % N; 

        const S1k = (S1 * k) % N;
        const S1k_Z1 = (S1k - Z1 + N) % N; 
        const d = (S1k_Z1 * R_inv) % N;

        return d.toString(16).padStart(64, '0');
    } catch (e) {
        return "ERROR: Could not perform modular inverse.";
    }
}


async function processTxid() {
    const txid = document.getElementById("txid_input").value.trim();
    const out = document.getElementById("out_txid");
    
    out.innerHTML = getOutputHeader() + "<pre>Fetching raw transaction data (Trying multiple APIs)...</pre>";
    
    if (txid.length !== 64) {
        out.innerHTML = getOutputHeader() + `<pre><span class='private-key'>Error: Invalid TXID length. Must be 64 hex characters.</span></pre>`;
        return;
    }
    
    let rawtx;
    try {
        rawtx = await getRawTx(txid);
        out.innerHTML = getOutputHeader() + `<pre>Raw data fetched. Parsing inputs and calculating Z values...</pre>`;
    } catch (e) {
        out.innerHTML = getOutputHeader() + `<pre><span class='private-key'>Error fetching raw TX: ${e.message}. Check network connection or TXID.</span></pre>`;
        return;
    }

    let parsed_data;
    try {
        parsed_data = parsingRaw(rawtx);
    } catch (e) {
        out.innerHTML = getOutputHeader() + `<pre><span class='private-key'>Error parsing raw TX: ${e.message}</span></pre>`;
        return;
    }

    const rsz_results = getrsz(parsed_data);
    
    let output_html = "<h3>Transaction Analysis Results</h3>";
    let private_key_found = false;
    let found_r_reuse = false;
    
    for (let i = 0; i < rsz_results.length; i++) {
        const current = rsz_results[i];
        
        output_html += `
        <p><strong>[+] Input No: ${current.input_index}</strong></p>
        <pre>  Address: ${current.addr}
  R: ${current.r}
  S: ${current.s}
  Z (Hash): ${current.z}</pre>`;

        if (i > 0) {
            const previous = rsz_results[i - 1];
            if (current.r === previous.r) {
                found_r_reuse = true;
                output_html += `<p class="private-key">!!! R REUSE DETECTED BETWEEN INPUT ${i-1} AND ${i} !!!</p>`;
                
                const private_key = recover_private_key(
                    hexToBigInt(current.r),
                    hexToBigInt(previous.s),
                    hexToBigInt(current.s),
                    hexToBigInt(previous.z),
                    hexToBigInt(current.z)
                );
                
                if (private_key.startsWith("ERROR")) {
                     output_html += `<p class="private-key">Private Key: ERROR RECOVERING KEY. ${private_key}</p>`;
                } else {
                    output_html += `<p class="private-key">Private Key Found: ${private_key}</p>`;
                    private_key_found = true;
                }
            }
        }
    }
    
    if (!found_r_reuse) {
        output_html += "<p><strong>[+] No matching R values found between consecutive inputs. Private Key: Not Found</strong></p>";
    } else if (private_key_found) {
        output_html += "<p class='private-key'>!!! PRIVATE KEY RECOVERY SUCCESSFUL !!!</p>";
    }

    out.innerHTML = getOutputHeader() + output_html;
}


/* ---------------------- 2. Address → HASH160/Witness Program ---------------------- */
function addrToHash(){
    const a = document.getElementById("addr2").value.trim();
    const out = document.getElementById("out_hash");
    out.innerHTML = '';
    
    try {
        let content = '';
        if (a.startsWith('1') || a.startsWith('3')) {
            const decodedBytes = b58_decode_check(a); 
            const versionByte = decodedBytes[0];
            
            if (decodedBytes.length !== 21) throw new Error('Invalid Base58 decoded length.');

            const hash160_hex = bytesToHex(decodedBytes.slice(1));
            
            content = 
                "Address Type: Base58Check\n" +
                "Version Byte: " + bytesToHex(new Uint8Array([versionByte])) + 
                " (" + (versionByte === 0 ? "P2PKH: 1..." : "P2SH: 3...") + ")\n" +
                "HASH160 (RIPEMD160): " + hash160_hex;

        } else if (a.startsWith('bc1q') || a.startsWith('tb1q') || a.startsWith('bc1p') || a.startsWith('tb1p')) {
            const decoded = bech32_decode_program(a);
            const program_hash = bytesToHex(decoded.program);
            
            content = 
                "Address Type: Bech32/Bech32m\n" +
                "Witness Version: " + decoded.version + 
                " (" + (decoded.version === 0 ? "SegWit" : "Taproot/Future") + ")\n" +
                "Witness Program (HASH): " + program_hash;
                
        } else {
            content = "Error: Unsupported address format. Must start with 1, 3, or bc1q/tb1q/bc1p/tb1p.";
        }
        
        out.innerHTML = getOutputHeader() + `<pre>${content}</pre>`;
    } catch(e){ 
        out.innerHTML = getOutputHeader() + `<pre>Error: ${e.message || "Invalid address format or decoding failed."}</pre>`;
    }
}


/* ---------------------- 3. Public Key → X and Y Coordinates ---------------------- */
function pubToCoords(){
    const out = document.getElementById("out_pk_coords");
    out.innerHTML = '';
    
    try{
        let pub = document.getElementById("pk_coords").value.trim();
        if(pub.length !== 66 && pub.length !== 130) {
            out.innerHTML = getOutputHeader() + `<pre>Error: Invalid Public Key Length (must be 66 or 130 hex characters).</pre>`;
            return;
        }

        const ec = new elliptic.ec("secp256k1");
        const point = ec.keyFromPublic(pub, 'hex').getPublic();
        
        let uncompressedPub = point.encode('hex', false);
        let compressedPub = point.encode('hex', true);

        let x_hex = point.getX().toString("hex").padStart(64,"0");
        let y_hex = point.getY().toString("hex").padStart(64,"0");
        
        let x_dec = BigInt("0x" + x_hex).toString();
        let y_dec = BigInt("0x" + y_hex).toString();

        let content =
            "Input Public Key: " + pub + "\n" +
            "Public Key (Compressed): " + compressedPub + "\n" +
            "Public Key (Uncompressed): " + uncompressedPub + "\n\n" +
            "--- COORDINATES (HEX) ---\n" +
            "X Coordinate: " + x_hex + "\n" +
            "Y Coordinate: " + y_hex + "\n\n" +
            "--- COORDINATES (DECIMAL) ---\n" +
            "X Coordinate (DECIMAL): " + x_dec + "\n" +
            "Y Coordinate (DECIMAL): " + y_dec;
            
        out.innerHTML = getOutputHeader() + `<pre>${content}</pre>`;

    } catch(e){ 
        out.innerHTML = getOutputHeader() + `<pre>Error: Invalid Public Key Format. Ensure the key is valid.</pre>`;
    }
}


/* ---------------------- 4. Public Key → Address ---------------------- */
function pubToAddr(){
    const out = document.getElementById("out_pk");
    out.innerHTML = '';
    
    try{
        let pub = document.getElementById("pk").value.trim();
        if(pub.length !== 66 && pub.length !== 130) {
            out.innerHTML = getOutputHeader() + `<pre>Error: Invalid Public Key Length (must be 66 or 130 hex characters).</pre>`;
            return;
        }

        const ec = new elliptic.ec("secp256k1");
        const point = ec.keyFromPublic(pub, 'hex').getPublic();

        let compressedPub = point.encode('hex', true);
        let address_comp = pubToAddr_P2PKH(compressedPub);
        
        let uncompressedPub = point.encode('hex', false);
        let address_uncomp = pubToAddr_P2PKH(uncompressedPub);

        let content =
            "Input Public Key: " + pub + "\n\n" +
            "1. Public Key (Compressed): " + compressedPub + "\n" +
            "2. P2PKH Address (Compressed Key Hash): " + address_comp + " (Standard)\n\n" +
            "3. Public Key (Uncompressed): " + uncompressedPub + "\n" +
            "4. P2PKH Address (Uncompressed Key Hash): " + address_uncomp + " (Legacy)";
            
        out.innerHTML = getOutputHeader() + `<pre>${content}</pre>`;

    } catch(e){ 
        out.innerHTML = getOutputHeader() + `<pre>Error: Invalid Public Key Format or Library Issue.</pre>`;
    }
}


/* ---------------------- 6. Address → Public Key (API Lookup) ---------------------- */
async function apiTry(url){
    try{
        let r = await fetch(url, { signal: AbortSignal.timeout(10000) });
        if(!r.ok) return null; 
        return await r.text(); 
    } catch {
        return null;
    }
}

async function findPublicKey(){
    let addr = document.getElementById("addr").value.trim();
    const out = document.getElementById("out_addr");
    out.innerHTML = getOutputHeader() + `<pre>Checking for Public Key via API (Blockchain.info)...</pre>`;
    
    if (!addr.startsWith('1')) {
        out.innerHTML = getOutputHeader() + `<pre>Error: Public Key lookup via API usually only works for P2PKH (starts with 1) addresses.</pre>`;
        return;
    }
    
    let url_direct = `https://blockchain.info/q/pubkeyaddr/${addr}`;
    let pubkey_response = await apiTry(url_direct);

    if (pubkey_response){
        if (pubkey_response.length >= 66 && (pubkey_response.startsWith("02") || pubkey_response.startsWith("03") || pubkey_response.startsWith("04"))){
            let content = getOutputHeader() + "✅ Public Key Found (via Blockchain.info):\n" + pubkey_response; 
            out.innerHTML = `<pre>${content}</pre>`;
             return;
        } else if (pubkey_response.includes("No public key for this address")) {
             out.innerHTML = getOutputHeader() + `<pre>❌ Public Key not found in Blockchain.info's index. (Perhaps no transactions yet or address type unsupported)</pre>`;
             return;
        }
    }
    
    out.innerHTML = getOutputHeader() + `<pre>❌ Public Key not found via API. The Public Key must have been exposed (e.g., when the coins were spent) for this tool to find it.</pre>`;
}


/* ---------------------- 7. RMD160 (HASH160) → ADDRESS LOGIC ---------------------- */
function rmdToAddress() {
    const hash160 = document.getElementById("rmd160_input").value.trim().toLowerCase();
    const out = document.getElementById("out_rmd160");
    out.innerHTML = '';

    if (hash160.length !== 40 || !/^[0-9a-f]{40}$/.test(hash160)) {
        out.innerHTML = getOutputHeader() + `<pre><span class='private-key'>Error: Invalid HASH160. Must be a 40-character hexadecimal string.</span></pre>`;
        return;
    }

    try {
        // P2PKH Address (Starts with '1'): Version Byte 00 (Hex)
        const p2pkh_addr = hash160ToAddress(hash160, "00");

        // P2SH Address (Starts with '3'): Version Byte 05 (Hex)
        const p2sh_addr = hash160ToAddress(hash160, "05");

        let content =
            "Input HASH160: " + hash160 + "\n\n" +
            "1. P2PKH Address (Version 00): " + p2pkh_addr + " (Legacy/Standard)\n" +
            "2. P2SH Address (Version 05): " + p2sh_addr + " (SegWit compatibility)";

        out.innerHTML = getOutputHeader() + `<pre>${content}</pre>`;

    } catch(e) {
        out.innerHTML = getOutputHeader() + `<pre>Error during conversion: ${e.message || "An unexpected error occurred."}</pre>`;
    }
}
</script>

</body>
</html>
